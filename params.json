{"name":"Promisekit","tagline":"Promises for iOS and OS X","body":"Promises Cookbook\r\n===============================\r\n\r\n## Recipe 0: Understand return values\r\nThe key to understanding promises is to understand how **return values** move through the promise resolution process. Each of the recipes, below, illustrates a different aspect of this.\r\n\r\nA promise is essentially a function pointer. You can pass the function pointer around, but you don't get the value out until you *call* it.\r\nThe way to *call* a promise is to ```then``` it. However, because the function is asynchronous, it can't pass its return value to the left. Instead, it passes it into its ```then``` block.\r\n\r\n## Recipe 1: Get the value from a promise\r\n\r\n```objc\r\n// Method signature\r\n\r\n// Promise resolves to User instance\r\n- (PMKPromise *)loginToRemoteServer:(NSString *)userId; \r\n```\r\n\r\n\r\n```objc\r\n// Getting the value out.\r\n[self loginToRemoteServer:userId].then(^(User *user) {\r\n    self.user = user;\r\n});\r\n```\r\n### Notes\r\n* We always get the value(s) out of promises via side effects.\r\n* It's good practice to document the return type of promise-returning methods, since the method signature no longer does so.\r\n\r\n## Recipe 2: Handle errors\r\nEvery promise actually has the potential to return two different types: its \"promised\" type and ```NSError```. If the promise fails, the ```then``` block is skipped. \r\n\r\n```objc\r\n[self loginToRemoteServer:userId].then(^(User *user) {\r\n    self.user = user;\r\n}).catch(^(NSError *error){\r\n    // Something went wrong; deal with it here\r\n    ...\r\n    return nil;\r\n});\r\n```\r\n\r\n###Notes\r\n* Return anything other than ```NSError``` to stop the error from bubbling up.\r\n\r\n## Recipe 3: Create a sequence of promises\r\nA single promise is basically a fancy callback with a ```catch``` block. The power of promises comes from the fact that they are chainable (aka composable).\r\n\r\nFirst, look at the unchained (ie., nested) version. It is very similar to nested callbacks and just as with callbacks, if we added error handling to each promise, it would start to get messy.\r\n\r\n```objc\r\n// Method signatures\r\n\r\n// Promise resolves to User instance\r\n- (PMKPromise *)loginToRemoteServer:(NSString *)userId; \r\n\r\n// Promise resolves to NSDictionary of user data\r\n- (PMKPromise *)retrieveUserData:(User *)user; \r\n\r\n// Promise resolves to UIImage\r\n- (PMKPromise *)retrieveProfileImage:(NSURL *)imageURL; \r\n```\r\n\r\n```objc\r\n[self loginToRemoteServer:userId].then(^(User *user) {\r\n    self.user = user;\r\n    [self retrieveUserData:user].then(^(NSDictionary *userData){\r\n         self.user.data = userData;\r\n         [self retrieveProfileImage:userData.profileImageURL].then(^(UIIMage *userImage){\r\n               self.user.profileImage = userImage;\r\n         });\r\n    });\r\n})\r\n```\r\n\r\nHere is the chained version. Note the single catch block that simplifies error handling.\r\n\r\n```objc\r\n[self loginToRemoteServer:userId].then(^(User *user) {\r\n    self.user = user;\r\n    return [self retrieveUserData:user];\r\n}).then(^(NSDictionary *userData){\r\n    self.user.data = userData;\r\n    return [self retrieveProfileImage:userData.profileImageURL];\r\n}).then(^(UIImage *userImage){\r\n    self.user.profileImage = userImage;\r\n}).catch(^(NSError *){\r\n    // Catch any errors here\r\n    ...\r\n});\r\n```\r\n\r\n### Notes: Rules for chained return values\r\nNotice that in the chained version, each of the ```then``` blocks has a **return value**. Here's how it works:\r\n\r\n* A ```then``` block's non-error return value gets passed to the next ```then``` block;\r\n* If a ```then``` block returns ```NSError```, that value gets passed to the next ```catch``` block (skipping intervening ```then's```);\r\n* If a ```then``` block doesn't return a value, the next ```then``` is called as soon as the block completes.\r\n\r\n*And here's the most important part:*\r\n\r\n* If a ```then``` block returns a promise, the next ```then``` receives its resolved value. This is the magic that lets us write asynchronous code almost as if it's synchronous.\r\n\r\n\r\n## Recipe 4: Branching\r\n```objc\r\nmyURLPromise.then(^id(NSURL *url){ \r\n     if (url) {\r\n         return url; // Got my url, I'm done, return the value\r\n     }\r\n     else {\r\n         return myOtherURLPromise; // Not done, do some more work\r\n     }\r\n}).then(^(NSURL *url){\r\n    // Do something with URL ...\r\n});\r\n```\r\n\r\n###Notes\r\nUntil now, the [method signatures](http://fuckingblocksyntax.com/) of our ```then``` blocks have all omitted their return types. These return types are being filled in via introspection. But whenever a block returns more than one type (as may happen when branching), the return type must be explicitly typed to ```id```.\r\n\r\nIn this example, the first return value is ```NSURL *``` but the second is ```PMKPromise *```. The compiler won't accept that unless we specify the return type of the block as ```id```.\r\n\r\n## Recipe 5: Pass primitives to ```then``` block.\r\nYou can return primitives from a ```then``` block, but the arguments passed into the next block are always boxed (ie., wrapped as objects).\r\n\r\n```objc\r\nmyPromise.then(^{\r\n        ...\r\n        return 3;\r\n}).then(^(NSNumber *result){\r\n    NSInteger intResult = [result integerValue];\r\n    ...\r\n});\r\n```\r\n\r\n## Recipe 6: Wrap an asynchronous method inside a promise\r\nAny method that takes a callback (block) can be turned into a promise by wrapping it. Here, we're wrapping Firebase's oauth method.\r\n\r\n```objc\r\n// Promise resolves to FAuthData.\r\n- (PMKPromise *)firebaseAuthWithOAuthProvider:provider accessToken(NSString *)token\r\n{\r\n    PMKPromise *promise = [PMKPromise new:^(PMKPromiseFulfiller fulfill, PMKPromiseRejecter reject) {\r\n        [firebase authWithOAuthProvider:provider token:token withCompletionBlock:^(NSError *error, FAuthData *authData) {\r\n            if (error) {\r\n                reject(error);                            \r\n            }\r\n            else {\r\n                fulfill(authData);\r\n            }\r\n        }];\r\n    }];\r\n    return promise;\r\n}\r\n\r\n```\r\n\r\n## Recipe 7: Use promises as building blocks\r\n```objc\r\n// Promise returns User instance\r\n- (PMKPromise *)setupUserWithId:(NSString *)userId\r\n{\r\n    PMKPromise *promise;\r\n    if (self.user) {\r\n        promise = [PMKPromise promiseWithValue:self.user]; // Resolves immediately\r\n    }\r\n    else {\r\n        promise = [self loginToRemoteServer:userId];\r\n    }\r\n    return promise.then(^(User *user) {\r\n        self.user = user;\r\n        return [self retrieveUserData:user];\r\n    }).then(^(NSDictionary *userData){\r\n        self.user.data = userData;\r\n        return [self retrieveProfileImage:userData.profileImageURL];\r\n    }).then(^(UIImage *userImage){\r\n        self.user.profileImage = userImage;\r\n        return self.user; // Return set up User as promise fulfillment\r\n    }).catch(^(NSError *){\r\n         // Log error but re-throw so caller can handle it\r\n         // If we returned nil here, error would be considered handled\r\n         NSLog(@\"Error in setupUserWithId: %@\", error);\r\n         return error;\r\n    });\r\n}\r\n```\r\n... elsewhere ...\r\n\r\n```objc\r\n[self setupUserWithId:userId].then(^(User *user){\r\n    // User is set up; do something with it\r\n}).catch(^(NSError *error){\r\n    // Let app user know that there's a problem\r\n});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}